   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.matrix_init_user,"ax",@progbits
  11               		.weak	matrix_init_user
  13               	matrix_init_user:
  14               	.LFB10:
  15               		.file 1 "quantum/matrix.c"
   1:quantum/matrix.c **** /*
   2:quantum/matrix.c **** Copyright 2012 Jun Wako
   3:quantum/matrix.c **** Copyright 2014 Jack Humbert
   4:quantum/matrix.c **** 
   5:quantum/matrix.c **** This program is free software: you can redistribute it and/or modify
   6:quantum/matrix.c **** it under the terms of the GNU General Public License as published by
   7:quantum/matrix.c **** the Free Software Foundation, either version 2 of the License, or
   8:quantum/matrix.c **** (at your option) any later version.
   9:quantum/matrix.c **** 
  10:quantum/matrix.c **** This program is distributed in the hope that it will be useful,
  11:quantum/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  12:quantum/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13:quantum/matrix.c **** GNU General Public License for more details.
  14:quantum/matrix.c **** 
  15:quantum/matrix.c **** You should have received a copy of the GNU General Public License
  16:quantum/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  17:quantum/matrix.c **** */
  18:quantum/matrix.c **** #include <stdint.h>
  19:quantum/matrix.c **** #include <stdbool.h>
  20:quantum/matrix.c **** #if defined(__AVR__)
  21:quantum/matrix.c **** #include <avr/io.h>
  22:quantum/matrix.c **** #endif
  23:quantum/matrix.c **** #include "wait.h"
  24:quantum/matrix.c **** #include "print.h"
  25:quantum/matrix.c **** #include "debug.h"
  26:quantum/matrix.c **** #include "util.h"
  27:quantum/matrix.c **** #include "matrix.h"
  28:quantum/matrix.c **** #include "timer.h"
  29:quantum/matrix.c **** 
  30:quantum/matrix.c **** 
  31:quantum/matrix.c **** /* Set 0 if debouncing isn't needed */
  32:quantum/matrix.c **** 
  33:quantum/matrix.c **** #ifndef DEBOUNCING_DELAY
  34:quantum/matrix.c **** #   define DEBOUNCING_DELAY 5
  35:quantum/matrix.c **** #endif
  36:quantum/matrix.c **** 
  37:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
  38:quantum/matrix.c ****     static uint16_t debouncing_time;
  39:quantum/matrix.c ****     static bool debouncing = false;
  40:quantum/matrix.c **** #endif
  41:quantum/matrix.c **** 
  42:quantum/matrix.c **** #if (MATRIX_COLS <= 8)
  43:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 01234567\n")
  44:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse8(matrix_get_row(row))
  45:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop(matrix[i])
  46:quantum/matrix.c **** #    define ROW_SHIFTER ((uint8_t)1)
  47:quantum/matrix.c **** #elif (MATRIX_COLS <= 16)
  48:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF\n")
  49:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse16(matrix_get_row(row))
  50:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop16(matrix[i])
  51:quantum/matrix.c **** #    define ROW_SHIFTER ((uint16_t)1)
  52:quantum/matrix.c **** #elif (MATRIX_COLS <= 32)
  53:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF0123456789ABCDEF\n")
  54:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse32(matrix_get_row(row))
  55:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop32(matrix[i])
  56:quantum/matrix.c **** #    define ROW_SHIFTER  ((uint32_t)1)
  57:quantum/matrix.c **** #endif
  58:quantum/matrix.c **** 
  59:quantum/matrix.c **** #ifdef MATRIX_MASKED
  60:quantum/matrix.c ****     extern const matrix_row_t matrix_mask[];
  61:quantum/matrix.c **** #endif
  62:quantum/matrix.c **** 
  63:quantum/matrix.c **** static const uint8_t row_pins[MATRIX_ROWS] = MATRIX_ROW_PINS;
  64:quantum/matrix.c **** static const uint8_t col_pins[MATRIX_COLS] = MATRIX_COL_PINS;
  65:quantum/matrix.c **** 
  66:quantum/matrix.c **** /* matrix state(1:on, 0:off) */
  67:quantum/matrix.c **** static matrix_row_t matrix[MATRIX_ROWS];
  68:quantum/matrix.c **** 
  69:quantum/matrix.c **** static matrix_row_t matrix_raw[MATRIX_ROWS];
  70:quantum/matrix.c **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  71:quantum/matrix.c **** 
  72:quantum/matrix.c **** 
  73:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
  74:quantum/matrix.c ****     static void init_cols(void);
  75:quantum/matrix.c ****     static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row);
  76:quantum/matrix.c ****     static void unselect_rows(void);
  77:quantum/matrix.c ****     static void select_row(uint8_t row);
  78:quantum/matrix.c ****     static void unselect_row(uint8_t row);
  79:quantum/matrix.c **** #else // ROW2COL
  80:quantum/matrix.c ****     static void init_rows(void);
  81:quantum/matrix.c ****     static bool read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_col);
  82:quantum/matrix.c ****     static void unselect_cols(void);
  83:quantum/matrix.c ****     static void unselect_col(uint8_t col);
  84:quantum/matrix.c ****     static void select_col(uint8_t col);
  85:quantum/matrix.c **** #endif
  86:quantum/matrix.c **** 
  87:quantum/matrix.c **** __attribute__ ((weak))
  88:quantum/matrix.c **** void matrix_init_quantum(void) {
  89:quantum/matrix.c ****     matrix_init_kb();
  90:quantum/matrix.c **** }
  91:quantum/matrix.c **** 
  92:quantum/matrix.c **** __attribute__ ((weak))
  93:quantum/matrix.c **** void matrix_scan_quantum(void) {
  94:quantum/matrix.c ****     matrix_scan_kb();
  95:quantum/matrix.c **** }
  96:quantum/matrix.c **** 
  97:quantum/matrix.c **** __attribute__ ((weak))
  98:quantum/matrix.c **** void matrix_init_kb(void) {
  99:quantum/matrix.c ****     matrix_init_user();
 100:quantum/matrix.c **** }
 101:quantum/matrix.c **** 
 102:quantum/matrix.c **** __attribute__ ((weak))
 103:quantum/matrix.c **** void matrix_scan_kb(void) {
 104:quantum/matrix.c ****     matrix_scan_user();
 105:quantum/matrix.c **** }
 106:quantum/matrix.c **** 
 107:quantum/matrix.c **** __attribute__ ((weak))
 108:quantum/matrix.c **** void matrix_init_user(void) {
  16               		.loc 1 108 29 view -0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 109:quantum/matrix.c **** }
  22               		.loc 1 109 1 view .LVU1
  23               	/* epilogue start */
  24 0000 0895      		ret
  25               		.cfi_endproc
  26               	.LFE10:
  28               		.set	matrix_init_user.localalias.0,matrix_init_user
  29               		.section	.text.matrix_init_kb,"ax",@progbits
  30               		.weak	matrix_init_kb
  32               	matrix_init_kb:
  33               	.LFB8:
  98:quantum/matrix.c ****     matrix_init_user();
  34               		.loc 1 98 27 view -0
  35               		.cfi_startproc
  36               	/* prologue: function */
  37               	/* frame size = 0 */
  38               	/* stack size = 0 */
  39               	.L__stack_usage = 0
  99:quantum/matrix.c **** }
  40               		.loc 1 99 5 view .LVU3
  41 0000 0C94 0000 		jmp matrix_init_user
  42               	.LVL0:
  43               		.cfi_endproc
  44               	.LFE8:
  46               		.section	.text.matrix_init_quantum,"ax",@progbits
  47               		.weak	matrix_init_quantum
  49               	matrix_init_quantum:
  50               	.LFB6:
  88:quantum/matrix.c ****     matrix_init_kb();
  51               		.loc 1 88 32 view -0
  52               		.cfi_startproc
  53               	/* prologue: function */
  54               	/* frame size = 0 */
  55               	/* stack size = 0 */
  56               	.L__stack_usage = 0
  89:quantum/matrix.c **** }
  57               		.loc 1 89 5 view .LVU5
  58 0000 0C94 0000 		jmp matrix_init_kb
  59               	.LVL1:
  60               		.cfi_endproc
  61               	.LFE6:
  63               		.section	.text.matrix_scan_user,"ax",@progbits
  64               		.weak	matrix_scan_user
  66               	matrix_scan_user:
  67               	.LFB27:
  68               		.cfi_startproc
  69               	/* prologue: function */
  70               	/* frame size = 0 */
  71               	/* stack size = 0 */
  72               	.L__stack_usage = 0
  73               	/* epilogue start */
  74 0000 0895      		ret
  75               		.cfi_endproc
  76               	.LFE27:
  78               		.section	.text.matrix_scan_kb,"ax",@progbits
  79               		.weak	matrix_scan_kb
  81               	matrix_scan_kb:
  82               	.LFB9:
 103:quantum/matrix.c ****     matrix_scan_user();
  83               		.loc 1 103 27 view -0
  84               		.cfi_startproc
  85               	/* prologue: function */
  86               	/* frame size = 0 */
  87               	/* stack size = 0 */
  88               	.L__stack_usage = 0
 104:quantum/matrix.c **** }
  89               		.loc 1 104 5 view .LVU7
  90 0000 0C94 0000 		jmp matrix_scan_user
  91               	.LVL2:
  92               		.cfi_endproc
  93               	.LFE9:
  95               		.section	.text.matrix_scan_quantum,"ax",@progbits
  96               		.weak	matrix_scan_quantum
  98               	matrix_scan_quantum:
  99               	.LFB7:
  93:quantum/matrix.c ****     matrix_scan_kb();
 100               		.loc 1 93 32 view -0
 101               		.cfi_startproc
 102               	/* prologue: function */
 103               	/* frame size = 0 */
 104               	/* stack size = 0 */
 105               	.L__stack_usage = 0
  94:quantum/matrix.c **** }
 106               		.loc 1 94 5 view .LVU9
 107 0000 0C94 0000 		jmp matrix_scan_kb
 108               	.LVL3:
 109               		.cfi_endproc
 110               	.LFE7:
 112               		.section	.text.matrix_rows,"ax",@progbits
 113               	.global	matrix_rows
 115               	matrix_rows:
 116               	.LFB12:
 110:quantum/matrix.c **** 
 111:quantum/matrix.c **** __attribute__ ((weak))
 112:quantum/matrix.c **** void matrix_scan_user(void) {
 113:quantum/matrix.c **** }
 114:quantum/matrix.c **** 
 115:quantum/matrix.c **** inline
 116:quantum/matrix.c **** uint8_t matrix_rows(void) {
 117               		.loc 1 116 27 view -0
 118               		.cfi_startproc
 119               	/* prologue: function */
 120               	/* frame size = 0 */
 121               	/* stack size = 0 */
 122               	.L__stack_usage = 0
 117:quantum/matrix.c ****     return MATRIX_ROWS;
 123               		.loc 1 117 5 view .LVU11
 118:quantum/matrix.c **** }
 124               		.loc 1 118 1 is_stmt 0 view .LVU12
 125 0000 87E0      		ldi r24,lo8(7)
 126               	/* epilogue start */
 127 0002 0895      		ret
 128               		.cfi_endproc
 129               	.LFE12:
 131               		.section	.text.matrix_cols,"ax",@progbits
 132               	.global	matrix_cols
 134               	matrix_cols:
 135               	.LFB13:
 119:quantum/matrix.c **** 
 120:quantum/matrix.c **** inline
 121:quantum/matrix.c **** uint8_t matrix_cols(void) {
 136               		.loc 1 121 27 is_stmt 1 view -0
 137               		.cfi_startproc
 138               	/* prologue: function */
 139               	/* frame size = 0 */
 140               	/* stack size = 0 */
 141               	.L__stack_usage = 0
 122:quantum/matrix.c ****     return MATRIX_COLS;
 142               		.loc 1 122 5 view .LVU14
 123:quantum/matrix.c **** }
 143               		.loc 1 123 1 is_stmt 0 view .LVU15
 144 0000 8DE0      		ldi r24,lo8(13)
 145               	/* epilogue start */
 146 0002 0895      		ret
 147               		.cfi_endproc
 148               	.LFE13:
 150               		.section	.text.matrix_init,"ax",@progbits
 151               	.global	matrix_init
 153               	matrix_init:
 154               	.LFB14:
 124:quantum/matrix.c **** 
 125:quantum/matrix.c **** // void matrix_power_up(void) {
 126:quantum/matrix.c **** // #if (DIODE_DIRECTION == COL2ROW)
 127:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 128:quantum/matrix.c **** //         /* DDRxn */
 129:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 1) |= _BV(row_pins[r] & 0xF);
 130:quantum/matrix.c **** //         toggle_row(r);
 131:quantum/matrix.c **** //     }
 132:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 133:quantum/matrix.c **** //         /* PORTxn */
 134:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 2) |= _BV(col_pins[c] & 0xF);
 135:quantum/matrix.c **** //     }
 136:quantum/matrix.c **** // #else
 137:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 138:quantum/matrix.c **** //         /* DDRxn */
 139:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 1) |= _BV(col_pins[c] & 0xF);
 140:quantum/matrix.c **** //         toggle_col(c);
 141:quantum/matrix.c **** //     }
 142:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 143:quantum/matrix.c **** //         /* PORTxn */
 144:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 2) |= _BV(row_pins[r] & 0xF);
 145:quantum/matrix.c **** //     }
 146:quantum/matrix.c **** // #endif
 147:quantum/matrix.c **** // }
 148:quantum/matrix.c **** 
 149:quantum/matrix.c **** void matrix_init(void) {
 155               		.loc 1 149 24 is_stmt 1 view -0
 156               		.cfi_startproc
 157               	/* prologue: function */
 158               	/* frame size = 0 */
 159               	/* stack size = 0 */
 160               	.L__stack_usage = 0
 150:quantum/matrix.c **** 
 151:quantum/matrix.c ****     // To use PORTF disable JTAG with writing JTD bit twice within four cycles.
 152:quantum/matrix.c ****     #if  (defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB1287__) || defined(__AVR_ATmega32U4_
 153:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 161               		.loc 1 153 9 view .LVU17
 162               		.loc 1 153 15 is_stmt 0 view .LVU18
 163 0000 85B7      		in r24,0x35
 164 0002 8068      		ori r24,lo8(-128)
 165 0004 85BF      		out 0x35,r24
 154:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 166               		.loc 1 154 9 is_stmt 1 view .LVU19
 167               		.loc 1 154 15 is_stmt 0 view .LVU20
 168 0006 85B7      		in r24,0x35
 169 0008 8068      		ori r24,lo8(-128)
 170 000a 85BF      		out 0x35,r24
 155:quantum/matrix.c ****     #endif
 156:quantum/matrix.c **** 
 157:quantum/matrix.c ****     // initialize row and col
 158:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 159:quantum/matrix.c ****     unselect_rows();
 171               		.loc 1 159 5 is_stmt 1 view .LVU21
 172               	.LBB19:
 173               	.LBI19:
 160:quantum/matrix.c ****     init_cols();
 161:quantum/matrix.c **** #else // ROW2COL
 162:quantum/matrix.c ****     unselect_cols();
 163:quantum/matrix.c ****     init_rows();
 164:quantum/matrix.c **** #endif
 165:quantum/matrix.c **** 
 166:quantum/matrix.c ****     // initialize matrix state: all keys off
 167:quantum/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 168:quantum/matrix.c ****         matrix[i] = 0;
 169:quantum/matrix.c ****         matrix_raw[i] = 0;
 170:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 171:quantum/matrix.c ****     }
 172:quantum/matrix.c **** 
 173:quantum/matrix.c ****     matrix_init_quantum();
 174:quantum/matrix.c **** }
 175:quantum/matrix.c **** 
 176:quantum/matrix.c **** uint8_t matrix_scan(void)
 177:quantum/matrix.c **** {
 178:quantum/matrix.c **** 
 179:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 180:quantum/matrix.c **** 
 181:quantum/matrix.c ****     // Set row, read cols
 182:quantum/matrix.c ****     for (uint8_t current_row = 0; current_row < MATRIX_ROWS; current_row++) {
 183:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 184:quantum/matrix.c ****             bool matrix_changed = read_cols_on_row(matrix_debouncing, current_row);
 185:quantum/matrix.c **** 
 186:quantum/matrix.c ****             if (matrix_changed) {
 187:quantum/matrix.c ****                 debouncing = true;
 188:quantum/matrix.c ****                 debouncing_time = timer_read();
 189:quantum/matrix.c ****             }
 190:quantum/matrix.c **** 
 191:quantum/matrix.c **** #       else
 192:quantum/matrix.c ****             read_cols_on_row(matrix, current_row);
 193:quantum/matrix.c **** #       endif
 194:quantum/matrix.c **** 
 195:quantum/matrix.c ****     }
 196:quantum/matrix.c **** 
 197:quantum/matrix.c **** #else // ROW2COL
 198:quantum/matrix.c **** 
 199:quantum/matrix.c ****     // Set col, read rows
 200:quantum/matrix.c ****     for (uint8_t current_col = 0; current_col < MATRIX_COLS; current_col++) {
 201:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 202:quantum/matrix.c ****             bool matrix_changed = read_rows_on_col(matrix_debouncing, current_col);
 203:quantum/matrix.c ****             if (matrix_changed) {
 204:quantum/matrix.c ****                 debouncing = true;
 205:quantum/matrix.c ****                 debouncing_time = timer_read();
 206:quantum/matrix.c ****             }
 207:quantum/matrix.c **** #       else
 208:quantum/matrix.c ****              read_rows_on_col(matrix, current_col);
 209:quantum/matrix.c **** #       endif
 210:quantum/matrix.c **** 
 211:quantum/matrix.c ****     }
 212:quantum/matrix.c **** 
 213:quantum/matrix.c **** #endif
 214:quantum/matrix.c **** 
 215:quantum/matrix.c **** #   if (DEBOUNCING_DELAY > 0)
 216:quantum/matrix.c ****         if (debouncing && (timer_elapsed(debouncing_time) > DEBOUNCING_DELAY)) {
 217:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 218:quantum/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 219:quantum/matrix.c ****             }
 220:quantum/matrix.c ****             debouncing = false;
 221:quantum/matrix.c ****         }
 222:quantum/matrix.c **** #   endif
 223:quantum/matrix.c **** 
 224:quantum/matrix.c ****     matrix_scan_quantum();
 225:quantum/matrix.c ****     return 1;
 226:quantum/matrix.c **** }
 227:quantum/matrix.c **** 
 228:quantum/matrix.c **** bool matrix_is_modified(void)
 229:quantum/matrix.c **** {
 230:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
 231:quantum/matrix.c ****     if (debouncing) return false;
 232:quantum/matrix.c **** #endif
 233:quantum/matrix.c ****     return true;
 234:quantum/matrix.c **** }
 235:quantum/matrix.c **** 
 236:quantum/matrix.c **** inline
 237:quantum/matrix.c **** bool matrix_is_on(uint8_t row, uint8_t col)
 238:quantum/matrix.c **** {
 239:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 240:quantum/matrix.c **** }
 241:quantum/matrix.c **** 
 242:quantum/matrix.c **** inline
 243:quantum/matrix.c **** matrix_row_t matrix_get_row(uint8_t row)
 244:quantum/matrix.c **** {
 245:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 246:quantum/matrix.c ****     // switch blocker installed and the switch is always pressed.
 247:quantum/matrix.c **** #ifdef MATRIX_MASKED
 248:quantum/matrix.c ****     return matrix[row] & matrix_mask[row];
 249:quantum/matrix.c **** #else
 250:quantum/matrix.c ****     return matrix[row];
 251:quantum/matrix.c **** #endif
 252:quantum/matrix.c **** }
 253:quantum/matrix.c **** 
 254:quantum/matrix.c **** void matrix_print(void)
 255:quantum/matrix.c **** {
 256:quantum/matrix.c ****     print_matrix_header();
 257:quantum/matrix.c **** 
 258:quantum/matrix.c ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 259:quantum/matrix.c ****         phex(row); print(": ");
 260:quantum/matrix.c ****         print_matrix_row(row);
 261:quantum/matrix.c ****         print("\n");
 262:quantum/matrix.c ****     }
 263:quantum/matrix.c **** }
 264:quantum/matrix.c **** 
 265:quantum/matrix.c **** uint8_t matrix_key_count(void)
 266:quantum/matrix.c **** {
 267:quantum/matrix.c ****     uint8_t count = 0;
 268:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 269:quantum/matrix.c ****         count += matrix_bitpop(i);
 270:quantum/matrix.c ****     }
 271:quantum/matrix.c ****     return count;
 272:quantum/matrix.c **** }
 273:quantum/matrix.c **** 
 274:quantum/matrix.c **** 
 275:quantum/matrix.c **** 
 276:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 277:quantum/matrix.c **** 
 278:quantum/matrix.c **** static void init_cols(void)
 279:quantum/matrix.c **** {
 280:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_COLS; x++) {
 281:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 283:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 284:quantum/matrix.c ****     }
 285:quantum/matrix.c **** }
 286:quantum/matrix.c **** 
 287:quantum/matrix.c **** static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row)
 288:quantum/matrix.c **** {
 289:quantum/matrix.c ****     // Store last value of row prior to reading
 290:quantum/matrix.c ****     matrix_row_t last_row_value = current_matrix[current_row];
 291:quantum/matrix.c **** 
 292:quantum/matrix.c ****     // Clear data in matrix row
 293:quantum/matrix.c ****     current_matrix[current_row] = 0;
 294:quantum/matrix.c **** 
 295:quantum/matrix.c ****     // Select row and wait for row selecton to stabilize
 296:quantum/matrix.c ****     select_row(current_row);
 297:quantum/matrix.c ****     wait_us(30);
 298:quantum/matrix.c **** 
 299:quantum/matrix.c ****     // For each col...
 300:quantum/matrix.c ****     for(uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 301:quantum/matrix.c **** 
 302:quantum/matrix.c ****         // Select the col pin to read (active low)
 303:quantum/matrix.c ****         uint8_t pin = col_pins[col_index];
 304:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 305:quantum/matrix.c **** 
 306:quantum/matrix.c ****         // Populate the matrix row with the state of the col pin
 307:quantum/matrix.c ****         current_matrix[current_row] |=  pin_state ? 0 : (ROW_SHIFTER << col_index);
 308:quantum/matrix.c ****     }
 309:quantum/matrix.c **** 
 310:quantum/matrix.c ****     // Unselect row
 311:quantum/matrix.c ****     unselect_row(current_row);
 312:quantum/matrix.c **** 
 313:quantum/matrix.c ****     return (last_row_value != current_matrix[current_row]);
 314:quantum/matrix.c **** }
 315:quantum/matrix.c **** 
 316:quantum/matrix.c **** static void select_row(uint8_t row)
 317:quantum/matrix.c **** {
 318:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 320:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 321:quantum/matrix.c **** }
 322:quantum/matrix.c **** 
 323:quantum/matrix.c **** static void unselect_row(uint8_t row)
 324:quantum/matrix.c **** {
 325:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 326:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 327:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 328:quantum/matrix.c **** }
 329:quantum/matrix.c **** 
 330:quantum/matrix.c **** static void unselect_rows(void)
 174               		.loc 1 330 13 view .LVU22
 175               	.LBE19:
 331:quantum/matrix.c **** {
 332:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_ROWS; x++) {
 176               		.loc 1 332 5 view .LVU23
 177               	.LBB22:
 178               	.LBB20:
 179               		.loc 1 332 9 view .LVU24
 180               	.LVL4:
 181               		.loc 1 332 24 view .LVU25
 182 000c A0E0      		ldi r26,lo8(row_pins)
 183 000e B0E0      		ldi r27,hi8(row_pins)
 184               	.LBB21:
 333:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 334:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 185               		.loc 1 334 38 is_stmt 0 view .LVU26
 186 0010 61E0      		ldi r22,lo8(1)
 187 0012 70E0      		ldi r23,0
 188               	.LVL5:
 189               	.L10:
 333:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 190               		.loc 1 333 9 is_stmt 1 view .LVU27
 333:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 191               		.loc 1 333 17 is_stmt 0 view .LVU28
 192 0014 8D91      		ld r24,X+
 193               	.LVL6:
 194               		.loc 1 334 9 is_stmt 1 view .LVU29
 195               		.loc 1 334 34 is_stmt 0 view .LVU30
 196 0016 E82F      		mov r30,r24
 197 0018 E295      		swap r30
 198 001a EF70      		andi r30,lo8(15)
 199 001c F0E0      		ldi r31,0
 200 001e 41A1      		ldd r20,Z+33
 201               		.loc 1 334 38 view .LVU31
 202 0020 8F70      		andi r24,lo8(15)
 203               	.LVL7:
 204               		.loc 1 334 38 view .LVU32
 205 0022 9B01      		movw r18,r22
 206 0024 00C0      		rjmp 2f
 207               		1:
 208 0026 220F      		lsl r18
 209               		2:
 210 0028 8A95      		dec r24
 211 002a 02F4      		brpl 1b
 212               		.loc 1 334 34 view .LVU33
 213 002c 922F      		mov r25,r18
 214 002e 9095      		com r25
 215 0030 9423      		and r25,r20
 216 0032 91A3      		std Z+33,r25
 217               	.LVL8:
 335:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 218               		.loc 1 335 9 is_stmt 1 view .LVU34
 219               		.loc 1 335 34 is_stmt 0 view .LVU35
 220 0034 82A1      		ldd r24,Z+34
 221 0036 822B      		or r24,r18
 222 0038 82A3      		std Z+34,r24
 223               	.LBE21:
 332:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 224               		.loc 1 332 41 is_stmt 1 view .LVU36
 225               	.LVL9:
 332:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 226               		.loc 1 332 24 view .LVU37
 332:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 227               		.loc 1 332 5 is_stmt 0 view .LVU38
 228 003a 80E0      		ldi r24,hi8(row_pins+7)
 229 003c A030      		cpi r26,lo8(row_pins+7)
 230 003e B807      		cpc r27,r24
 231 0040 01F4      		brne .L10
 232 0042 A0E0      		ldi r26,lo8(col_pins)
 233 0044 B0E0      		ldi r27,hi8(col_pins)
 234               	.LVL10:
 332:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 235               		.loc 1 332 5 view .LVU39
 236               	.LBE20:
 237               	.LBE22:
 238               	.LBB23:
 239               	.LBB24:
 240               	.LBB25:
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 241               		.loc 1 282 38 view .LVU40
 242 0046 61E0      		ldi r22,lo8(1)
 243 0048 70E0      		ldi r23,0
 244               	.L11:
 245               	.LVL11:
 281:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 246               		.loc 1 281 9 is_stmt 1 view .LVU41
 281:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 247               		.loc 1 281 17 is_stmt 0 view .LVU42
 248 004a 8D91      		ld r24,X+
 249               	.LVL12:
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 250               		.loc 1 282 9 is_stmt 1 view .LVU43
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 251               		.loc 1 282 34 is_stmt 0 view .LVU44
 252 004c E82F      		mov r30,r24
 253 004e E295      		swap r30
 254 0050 EF70      		andi r30,lo8(15)
 255 0052 F0E0      		ldi r31,0
 256 0054 41A1      		ldd r20,Z+33
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 257               		.loc 1 282 38 view .LVU45
 258 0056 8F70      		andi r24,lo8(15)
 259               	.LVL13:
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 260               		.loc 1 282 38 view .LVU46
 261 0058 9B01      		movw r18,r22
 262 005a 00C0      		rjmp 2f
 263               		1:
 264 005c 220F      		lsl r18
 265               		2:
 266 005e 8A95      		dec r24
 267 0060 02F4      		brpl 1b
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 268               		.loc 1 282 34 view .LVU47
 269 0062 922F      		mov r25,r18
 270 0064 9095      		com r25
 271 0066 9423      		and r25,r20
 272 0068 91A3      		std Z+33,r25
 273               	.LVL14:
 283:quantum/matrix.c ****     }
 274               		.loc 1 283 9 is_stmt 1 view .LVU48
 283:quantum/matrix.c ****     }
 275               		.loc 1 283 34 is_stmt 0 view .LVU49
 276 006a 82A1      		ldd r24,Z+34
 277 006c 822B      		or r24,r18
 278 006e 82A3      		std Z+34,r24
 279               	.LBE25:
 280:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 280               		.loc 1 280 41 is_stmt 1 view .LVU50
 281               	.LVL15:
 280:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 282               		.loc 1 280 24 view .LVU51
 280:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 283               		.loc 1 280 5 is_stmt 0 view .LVU52
 284 0070 80E0      		ldi r24,hi8(col_pins+13)
 285 0072 A030      		cpi r26,lo8(col_pins+13)
 286 0074 B807      		cpc r27,r24
 287 0076 01F4      		brne .L11
 288 0078 E0E0      		ldi r30,lo8(matrix)
 289 007a F0E0      		ldi r31,hi8(matrix)
 290 007c A0E0      		ldi r26,lo8(matrix_debouncing)
 291 007e B0E0      		ldi r27,hi8(matrix_debouncing)
 292               	.LVL16:
 280:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 293               		.loc 1 280 5 view .LVU53
 294 0080 80E0      		ldi r24,lo8(matrix+14)
 295 0082 90E0      		ldi r25,hi8(matrix+14)
 296               	.L12:
 297               	.LBE24:
 298               	.LBE23:
 299               	.LBB26:
 168:quantum/matrix.c ****         matrix_raw[i] = 0;
 300               		.loc 1 168 9 is_stmt 1 discriminator 3 view .LVU54
 168:quantum/matrix.c ****         matrix_raw[i] = 0;
 301               		.loc 1 168 19 is_stmt 0 discriminator 3 view .LVU55
 302 0084 1192      		st Z+,__zero_reg__
 303 0086 1192      		st Z+,__zero_reg__
 169:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 304               		.loc 1 169 9 is_stmt 1 discriminator 3 view .LVU56
 170:quantum/matrix.c ****     }
 305               		.loc 1 170 9 discriminator 3 view .LVU57
 170:quantum/matrix.c ****     }
 306               		.loc 1 170 30 is_stmt 0 discriminator 3 view .LVU58
 307 0088 1D92      		st X+,__zero_reg__
 308 008a 1D92      		st X+,__zero_reg__
 167:quantum/matrix.c ****         matrix[i] = 0;
 309               		.loc 1 167 40 is_stmt 1 discriminator 3 view .LVU59
 310               	.LVL17:
 167:quantum/matrix.c ****         matrix[i] = 0;
 311               		.loc 1 167 23 discriminator 3 view .LVU60
 167:quantum/matrix.c ****         matrix[i] = 0;
 312               		.loc 1 167 5 is_stmt 0 discriminator 3 view .LVU61
 313 008c 8E17      		cp r24,r30
 314 008e 9F07      		cpc r25,r31
 315 0090 01F4      		brne .L12
 316               	.LBE26:
 173:quantum/matrix.c **** }
 317               		.loc 1 173 5 is_stmt 1 view .LVU62
 318 0092 0C94 0000 		jmp matrix_init_quantum
 319               	.LVL18:
 320               		.cfi_endproc
 321               	.LFE14:
 323               		.section	.text.matrix_scan,"ax",@progbits
 324               	.global	matrix_scan
 326               	matrix_scan:
 327               	.LFB15:
 177:quantum/matrix.c **** 
 328               		.loc 1 177 1 view -0
 329               		.cfi_startproc
 330 0000 2F92      		push r2
 331               	.LCFI0:
 332               		.cfi_def_cfa_offset 3
 333               		.cfi_offset 2, -2
 334 0002 3F92      		push r3
 335               	.LCFI1:
 336               		.cfi_def_cfa_offset 4
 337               		.cfi_offset 3, -3
 338 0004 4F92      		push r4
 339               	.LCFI2:
 340               		.cfi_def_cfa_offset 5
 341               		.cfi_offset 4, -4
 342 0006 5F92      		push r5
 343               	.LCFI3:
 344               		.cfi_def_cfa_offset 6
 345               		.cfi_offset 5, -5
 346 0008 6F92      		push r6
 347               	.LCFI4:
 348               		.cfi_def_cfa_offset 7
 349               		.cfi_offset 6, -6
 350 000a 7F92      		push r7
 351               	.LCFI5:
 352               		.cfi_def_cfa_offset 8
 353               		.cfi_offset 7, -7
 354 000c 8F92      		push r8
 355               	.LCFI6:
 356               		.cfi_def_cfa_offset 9
 357               		.cfi_offset 8, -8
 358 000e 9F92      		push r9
 359               	.LCFI7:
 360               		.cfi_def_cfa_offset 10
 361               		.cfi_offset 9, -9
 362 0010 AF92      		push r10
 363               	.LCFI8:
 364               		.cfi_def_cfa_offset 11
 365               		.cfi_offset 10, -10
 366 0012 BF92      		push r11
 367               	.LCFI9:
 368               		.cfi_def_cfa_offset 12
 369               		.cfi_offset 11, -11
 370 0014 CF92      		push r12
 371               	.LCFI10:
 372               		.cfi_def_cfa_offset 13
 373               		.cfi_offset 12, -12
 374 0016 DF92      		push r13
 375               	.LCFI11:
 376               		.cfi_def_cfa_offset 14
 377               		.cfi_offset 13, -13
 378 0018 EF92      		push r14
 379               	.LCFI12:
 380               		.cfi_def_cfa_offset 15
 381               		.cfi_offset 14, -14
 382 001a FF92      		push r15
 383               	.LCFI13:
 384               		.cfi_def_cfa_offset 16
 385               		.cfi_offset 15, -15
 386 001c 0F93      		push r16
 387               	.LCFI14:
 388               		.cfi_def_cfa_offset 17
 389               		.cfi_offset 16, -16
 390 001e 1F93      		push r17
 391               	.LCFI15:
 392               		.cfi_def_cfa_offset 18
 393               		.cfi_offset 17, -17
 394 0020 CF93      		push r28
 395               	.LCFI16:
 396               		.cfi_def_cfa_offset 19
 397               		.cfi_offset 28, -18
 398 0022 DF93      		push r29
 399               	.LCFI17:
 400               		.cfi_def_cfa_offset 20
 401               		.cfi_offset 29, -19
 402               	/* prologue: function */
 403               	/* frame size = 0 */
 404               	/* stack size = 18 */
 405               	.L__stack_usage = 18
 182:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 406               		.loc 1 182 5 view .LVU64
 407               	.LBB40:
 182:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 408               		.loc 1 182 10 view .LVU65
 409               	.LVL19:
 182:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 410               		.loc 1 182 35 view .LVU66
 411 0024 00E0      		ldi r16,lo8(matrix_debouncing)
 412 0026 10E0      		ldi r17,hi8(matrix_debouncing)
 413 0028 80E0      		ldi r24,lo8(row_pins)
 414 002a C82E      		mov r12,r24
 415 002c 80E0      		ldi r24,hi8(row_pins)
 416 002e D82E      		mov r13,r24
 417               	.LBE40:
 177:quantum/matrix.c **** 
 418               		.loc 1 177 1 is_stmt 0 view .LVU67
 419 0030 1801      		movw r2,r16
 420               	.LBB64:
 421               	.LBB41:
 422               	.LBB42:
 423               	.LBB43:
 424               	.LBB44:
 425               	.LBB45:
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 426               		.loc 1 319 34 view .LVU68
 427 0032 EE24      		clr r14
 428 0034 E394      		inc r14
 429 0036 F12C      		mov r15,__zero_reg__
 430               	.LBE45:
 431               	.LBE44:
 432               	.LBE43:
 433               	.LBE42:
 187:quantum/matrix.c ****                 debouncing_time = timer_read();
 434               		.loc 1 187 28 view .LVU69
 435 0038 6624      		clr r6
 436 003a 6394      		inc r6
 437               	.LVL20:
 438               	.L20:
 184:quantum/matrix.c **** 
 439               		.loc 1 184 13 is_stmt 1 view .LVU70
 440               	.LBB61:
 441               	.LBI42:
 287:quantum/matrix.c **** {
 442               		.loc 1 287 13 view .LVU71
 443               	.LBB59:
 290:quantum/matrix.c **** 
 444               		.loc 1 290 5 view .LVU72
 290:quantum/matrix.c **** 
 445               		.loc 1 290 18 is_stmt 0 view .LVU73
 446 003c D101      		movw r26,r2
 447 003e 8D90      		ld r8,X+
 448 0040 9D90      		ld r9,X+
 449 0042 1D01      		movw r2,r26
 450               	.LVL21:
 293:quantum/matrix.c **** 
 451               		.loc 1 293 5 is_stmt 1 view .LVU74
 293:quantum/matrix.c **** 
 452               		.loc 1 293 33 is_stmt 0 view .LVU75
 453 0044 1E92      		st -X,__zero_reg__
 454 0046 1E92      		st -X,__zero_reg__
 296:quantum/matrix.c ****     wait_us(30);
 455               		.loc 1 296 5 is_stmt 1 view .LVU76
 456               	.LVL22:
 457               	.LBB47:
 458               	.LBI44:
 316:quantum/matrix.c **** {
 459               		.loc 1 316 13 view .LVU77
 460               	.LBB46:
 318:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 461               		.loc 1 318 5 view .LVU78
 318:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 462               		.loc 1 318 13 is_stmt 0 view .LVU79
 463 0048 E601      		movw r28,r12
 464 004a 8991      		ld r24,Y+
 465 004c 6E01      		movw r12,r28
 466               	.LVL23:
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 467               		.loc 1 319 5 is_stmt 1 view .LVU80
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 468               		.loc 1 319 30 is_stmt 0 view .LVU81
 469 004e E82F      		mov r30,r24
 470 0050 E295      		swap r30
 471 0052 EF70      		andi r30,lo8(15)
 472 0054 F0E0      		ldi r31,0
 473 0056 91A1      		ldd r25,Z+33
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 474               		.loc 1 319 34 view .LVU82
 475 0058 8F70      		andi r24,lo8(15)
 476               	.LVL24:
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 477               		.loc 1 319 34 view .LVU83
 478 005a 9701      		movw r18,r14
 479 005c 00C0      		rjmp 2f
 480               		1:
 481 005e 220F      		lsl r18
 482               		2:
 483 0060 8A95      		dec r24
 484 0062 02F4      		brpl 1b
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 485               		.loc 1 319 30 view .LVU84
 486 0064 892F      		mov r24,r25
 487 0066 822B      		or r24,r18
 488 0068 81A3      		std Z+33,r24
 489               	.LVL25:
 320:quantum/matrix.c **** }
 490               		.loc 1 320 5 is_stmt 1 view .LVU85
 320:quantum/matrix.c **** }
 491               		.loc 1 320 30 is_stmt 0 view .LVU86
 492 006a 82A1      		ldd r24,Z+34
 493 006c 722E      		mov r7,r18
 494 006e 7094      		com r7
 495 0070 8721      		and r24,r7
 496 0072 82A3      		std Z+34,r24
 497               	.LVL26:
 320:quantum/matrix.c **** }
 498               		.loc 1 320 30 view .LVU87
 499               	.LBE46:
 500               	.LBE47:
 297:quantum/matrix.c **** 
 501               		.loc 1 297 5 is_stmt 1 view .LVU88
 502               	.LBB48:
 503               	.LBI48:
 504               		.file 2 "/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 189:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #else
 190:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	{
 196:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		{
 200:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		}
 204:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		return;
 205:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	}
 206:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	else
 207:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
 210:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** }
 211:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 212:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /**
 213:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 215:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 217:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 220:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 222:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 226:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 231:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 236:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    respectively.
 240:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 241:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \note
 242:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 243:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 253:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****  */
 254:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** void
 255:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** _delay_us(double __us)
 505               		.loc 2 255 1 view .LVU89
 506               	.LBB49:
 256:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 257:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	double __tmp ;
 507               		.loc 2 257 2 view .LVU90
 258:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 508               		.loc 2 261 2 view .LVU91
 262:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 509               		.loc 2 262 2 view .LVU92
 263:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 510               		.loc 2 263 2 view .LVU93
 264:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 265:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 268:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 271:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#else
 272:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		//round up by default
 273:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 511               		.loc 2 273 3 view .LVU94
 274:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 275:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 276:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 512               		.loc 2 276 2 view .LVU95
 513 0074 D0EA      		ldi r29,lo8(-96)
 514 0076 DA95      	1:	dec r29
 515 0078 01F4      		brne 1b
 516               	.LVL27:
 517               		.loc 2 276 2 is_stmt 0 view .LVU96
 518               	.LBE49:
 519               	.LBE48:
 300:quantum/matrix.c **** 
 520               		.loc 1 300 5 is_stmt 1 view .LVU97
 521               	.LBB51:
 300:quantum/matrix.c **** 
 522               		.loc 1 300 9 view .LVU98
 300:quantum/matrix.c **** 
 523               		.loc 1 300 32 view .LVU99
 524 007a 60E0      		ldi r22,lo8(col_pins)
 525 007c 70E0      		ldi r23,hi8(col_pins)
 526               	.LBE51:
 527               	.LBB54:
 528               	.LBB50:
 529               		.loc 2 276 2 is_stmt 0 view .LVU100
 530 007e 90E0      		ldi r25,0
 531 0080 80E0      		ldi r24,0
 532               	.LVL28:
 533               	.L18:
 534               		.loc 2 276 2 view .LVU101
 535               	.LBE50:
 536               	.LBE54:
 537               	.LBB55:
 538               	.LBB52:
 303:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 539               		.loc 1 303 9 is_stmt 1 view .LVU102
 303:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 540               		.loc 1 303 17 is_stmt 0 view .LVU103
 541 0082 EB01      		movw r28,r22
 542 0084 5990      		ld r5,Y+
 543 0086 BE01      		movw r22,r28
 544               	.LVL29:
 304:quantum/matrix.c **** 
 545               		.loc 1 304 9 is_stmt 1 view .LVU104
 304:quantum/matrix.c **** 
 546               		.loc 1 304 30 is_stmt 0 view .LVU105
 547 0088 452D      		mov r20,r5
 548 008a 4295      		swap r20
 549 008c 4F70      		andi r20,lo8(15)
 550 008e 50E0      		ldi r21,0
 551 0090 EA01      		movw r28,r20
 552 0092 48A0      		ldd r4,Y+32
 553               	.LVL30:
 307:quantum/matrix.c ****     }
 554               		.loc 1 307 9 is_stmt 1 view .LVU106
 307:quantum/matrix.c ****     }
 555               		.loc 1 307 37 is_stmt 0 view .LVU107
 556 0094 AD90      		ld r10,X+
 557 0096 BC90      		ld r11,X
 558 0098 1197      		sbiw r26,1
 304:quantum/matrix.c **** 
 559               		.loc 1 304 51 view .LVU108
 560 009a 552D      		mov r21,r5
 561 009c 5F70      		andi r21,lo8(15)
 562               	.LVL31:
 304:quantum/matrix.c **** 
 563               		.loc 1 304 51 view .LVU109
 564 009e E701      		movw r28,r14
 565 00a0 00C0      		rjmp 2f
 566               		1:
 567 00a2 CC0F      		lsl r28
 568 00a4 DD1F      		rol r29
 569               		2:
 570 00a6 5A95      		dec r21
 571 00a8 02F4      		brpl 1b
 572 00aa AE01      		movw r20,r28
 304:quantum/matrix.c **** 
 573               		.loc 1 304 49 view .LVU110
 574 00ac 4421      		and r20,r4
 307:quantum/matrix.c ****     }
 575               		.loc 1 307 55 view .LVU111
 576 00ae 01F0      		breq .+2
 577 00b0 00C0      		rjmp .L25
 578 00b2 A701      		movw r20,r14
 579 00b4 082E      		mov r0,r24
 580 00b6 00C0      		rjmp 2f
 581               		1:
 582 00b8 440F      		lsl r20
 583 00ba 551F      		rol r21
 584               		2:
 585 00bc 0A94      		dec r0
 586 00be 02F4      		brpl 1b
 587               	.LVL32:
 588               	.L17:
 307:quantum/matrix.c ****     }
 589               		.loc 1 307 37 view .LVU112
 590 00c0 4A29      		or r20,r10
 591 00c2 5B29      		or r21,r11
 592 00c4 1196      		adiw r26,1
 593 00c6 5C93      		st X,r21
 594 00c8 4E93      		st -X,r20
 595               	.LBE52:
 300:quantum/matrix.c **** 
 596               		.loc 1 300 57 is_stmt 1 view .LVU113
 597               	.LVL33:
 300:quantum/matrix.c **** 
 598               		.loc 1 300 32 view .LVU114
 599 00ca 0196      		adiw r24,1
 600               	.LVL34:
 300:quantum/matrix.c **** 
 601               		.loc 1 300 5 is_stmt 0 view .LVU115
 602 00cc 8D30      		cpi r24,13
 603 00ce 9105      		cpc r25,__zero_reg__
 604 00d0 01F4      		brne .L18
 605               	.LBE55:
 311:quantum/matrix.c **** 
 606               		.loc 1 311 5 is_stmt 1 view .LVU116
 607               	.LVL35:
 608               	.LBB56:
 609               	.LBI56:
 323:quantum/matrix.c **** {
 610               		.loc 1 323 13 view .LVU117
 611               	.LBB57:
 325:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 612               		.loc 1 325 5 view .LVU118
 326:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 613               		.loc 1 326 5 view .LVU119
 326:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 614               		.loc 1 326 30 is_stmt 0 view .LVU120
 615 00d2 81A1      		ldd r24,Z+33
 616               	.LVL36:
 326:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 617               		.loc 1 326 30 view .LVU121
 618 00d4 7822      		and r7,r24
 619 00d6 71A2      		std Z+33,r7
 327:quantum/matrix.c **** }
 620               		.loc 1 327 5 is_stmt 1 view .LVU122
 327:quantum/matrix.c **** }
 621               		.loc 1 327 30 is_stmt 0 view .LVU123
 622 00d8 82A1      		ldd r24,Z+34
 623 00da 282B      		or r18,r24
 624 00dc 22A3      		std Z+34,r18
 625               	.LVL37:
 327:quantum/matrix.c **** }
 626               		.loc 1 327 30 view .LVU124
 627               	.LBE57:
 628               	.LBE56:
 313:quantum/matrix.c **** }
 629               		.loc 1 313 5 is_stmt 1 view .LVU125
 313:quantum/matrix.c **** }
 630               		.loc 1 313 5 is_stmt 0 view .LVU126
 631               	.LBE59:
 632               	.LBE61:
 186:quantum/matrix.c ****                 debouncing = true;
 633               		.loc 1 186 13 is_stmt 1 view .LVU127
 186:quantum/matrix.c ****                 debouncing = true;
 634               		.loc 1 186 16 is_stmt 0 view .LVU128
 635 00de 8D91      		ld r24,X+
 636 00e0 9C91      		ld r25,X
 637 00e2 8816      		cp r8,r24
 638 00e4 9906      		cpc r9,r25
 639 00e6 01F0      		breq .L19
 187:quantum/matrix.c ****                 debouncing_time = timer_read();
 640               		.loc 1 187 17 is_stmt 1 view .LVU129
 187:quantum/matrix.c ****                 debouncing_time = timer_read();
 641               		.loc 1 187 28 is_stmt 0 view .LVU130
 642 00e8 6092 0000 		sts debouncing,r6
 188:quantum/matrix.c ****             }
 643               		.loc 1 188 17 is_stmt 1 view .LVU131
 188:quantum/matrix.c ****             }
 644               		.loc 1 188 35 is_stmt 0 view .LVU132
 645 00ec 0E94 0000 		call timer_read
 646               	.LVL38:
 188:quantum/matrix.c ****             }
 647               		.loc 1 188 33 view .LVU133
 648 00f0 9093 0000 		sts debouncing_time+1,r25
 649 00f4 8093 0000 		sts debouncing_time,r24
 650               	.L19:
 651               	.LBE41:
 182:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 652               		.loc 1 182 62 is_stmt 1 discriminator 2 view .LVU134
 653               	.LVL39:
 182:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 654               		.loc 1 182 35 discriminator 2 view .LVU135
 182:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 655               		.loc 1 182 5 is_stmt 0 discriminator 2 view .LVU136
 656 00f8 D0E0      		ldi r29,lo8(matrix_debouncing+14)
 657 00fa 2D16      		cp r2,r29
 658 00fc D0E0      		ldi r29,hi8(matrix_debouncing+14)
 659 00fe 3D06      		cpc r3,r29
 660 0100 01F0      		breq .+2
 661 0102 00C0      		rjmp .L20
 662               	.LBE64:
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 663               		.loc 1 216 9 is_stmt 1 view .LVU137
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 664               		.loc 1 216 12 is_stmt 0 view .LVU138
 665 0104 8091 0000 		lds r24,debouncing
 666 0108 8823      		tst r24
 667 010a 01F0      		breq .L22
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 668               		.loc 1 216 28 discriminator 1 view .LVU139
 669 010c 8091 0000 		lds r24,debouncing_time
 670 0110 9091 0000 		lds r25,debouncing_time+1
 671 0114 0E94 0000 		call timer_elapsed
 672               	.LVL40:
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 673               		.loc 1 216 24 discriminator 1 view .LVU140
 674 0118 0697      		sbiw r24,6
 675 011a 00F0      		brlo .L22
 676 011c E0E0      		ldi r30,lo8(matrix)
 677 011e F0E0      		ldi r31,hi8(matrix)
 678               	.L24:
 679               	.LBB65:
 218:quantum/matrix.c ****             }
 680               		.loc 1 218 17 is_stmt 1 discriminator 3 view .LVU141
 218:quantum/matrix.c ****             }
 681               		.loc 1 218 46 is_stmt 0 discriminator 3 view .LVU142
 682 0120 D801      		movw r26,r16
 683 0122 8D91      		ld r24,X+
 684 0124 9D91      		ld r25,X+
 685 0126 8D01      		movw r16,r26
 218:quantum/matrix.c ****             }
 686               		.loc 1 218 27 discriminator 3 view .LVU143
 687 0128 8193      		st Z+,r24
 688 012a 9193      		st Z+,r25
 217:quantum/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 689               		.loc 1 217 50 is_stmt 1 discriminator 3 view .LVU144
 690               	.LVL41:
 217:quantum/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 691               		.loc 1 217 33 discriminator 3 view .LVU145
 217:quantum/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 692               		.loc 1 217 13 is_stmt 0 discriminator 3 view .LVU146
 693 012c B0E0      		ldi r27,hi8(matrix_debouncing+14)
 694 012e 0030      		cpi r16,lo8(matrix_debouncing+14)
 695 0130 1B07      		cpc r17,r27
 696 0132 01F4      		brne .L24
 697               	.LBE65:
 220:quantum/matrix.c ****         }
 698               		.loc 1 220 13 is_stmt 1 view .LVU147
 220:quantum/matrix.c ****         }
 699               		.loc 1 220 24 is_stmt 0 view .LVU148
 700 0134 1092 0000 		sts debouncing,__zero_reg__
 701               	.L22:
 224:quantum/matrix.c ****     return 1;
 702               		.loc 1 224 5 is_stmt 1 view .LVU149
 703 0138 0E94 0000 		call matrix_scan_quantum
 704               	.LVL42:
 225:quantum/matrix.c **** }
 705               		.loc 1 225 5 view .LVU150
 226:quantum/matrix.c **** 
 706               		.loc 1 226 1 is_stmt 0 view .LVU151
 707 013c 81E0      		ldi r24,lo8(1)
 708               	/* epilogue start */
 709 013e DF91      		pop r29
 710 0140 CF91      		pop r28
 711 0142 1F91      		pop r17
 712 0144 0F91      		pop r16
 713 0146 FF90      		pop r15
 714 0148 EF90      		pop r14
 715 014a DF90      		pop r13
 716 014c CF90      		pop r12
 717               	.LVL43:
 226:quantum/matrix.c **** 
 718               		.loc 1 226 1 view .LVU152
 719 014e BF90      		pop r11
 720 0150 AF90      		pop r10
 721 0152 9F90      		pop r9
 722 0154 8F90      		pop r8
 226:quantum/matrix.c **** 
 723               		.loc 1 226 1 view .LVU153
 724 0156 7F90      		pop r7
 725 0158 6F90      		pop r6
 726 015a 5F90      		pop r5
 727               	.LVL44:
 226:quantum/matrix.c **** 
 728               		.loc 1 226 1 view .LVU154
 729 015c 4F90      		pop r4
 730 015e 3F90      		pop r3
 731 0160 2F90      		pop r2
 732 0162 0895      		ret
 733               	.LVL45:
 734               	.L25:
 735               	.LBB66:
 736               	.LBB63:
 737               	.LBB62:
 738               	.LBB60:
 739               	.LBB58:
 740               	.LBB53:
 307:quantum/matrix.c ****     }
 741               		.loc 1 307 55 view .LVU155
 742 0164 50E0      		ldi r21,0
 743               	.LVL46:
 307:quantum/matrix.c ****     }
 744               		.loc 1 307 55 view .LVU156
 745 0166 40E0      		ldi r20,0
 746 0168 00C0      		rjmp .L17
 747               	.LBE53:
 748               	.LBE58:
 749               	.LBE60:
 750               	.LBE62:
 751               	.LBE63:
 752               	.LBE66:
 753               		.cfi_endproc
 754               	.LFE15:
 756               		.section	.text.matrix_is_modified,"ax",@progbits
 757               	.global	matrix_is_modified
 759               	matrix_is_modified:
 760               	.LFB16:
 229:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
 761               		.loc 1 229 1 is_stmt 1 view -0
 762               		.cfi_startproc
 763               	/* prologue: function */
 764               	/* frame size = 0 */
 765               	/* stack size = 0 */
 766               	.L__stack_usage = 0
 231:quantum/matrix.c **** #endif
 767               		.loc 1 231 5 view .LVU158
 231:quantum/matrix.c **** #endif
 768               		.loc 1 231 8 is_stmt 0 view .LVU159
 769 0000 9091 0000 		lds r25,debouncing
 234:quantum/matrix.c **** 
 770               		.loc 1 234 1 view .LVU160
 771 0004 81E0      		ldi r24,lo8(1)
 772 0006 8927      		eor r24,r25
 773               	/* epilogue start */
 774 0008 0895      		ret
 775               		.cfi_endproc
 776               	.LFE16:
 778               		.section	.text.matrix_is_on,"ax",@progbits
 779               	.global	matrix_is_on
 781               	matrix_is_on:
 782               	.LVL47:
 783               	.LFB17:
 238:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 784               		.loc 1 238 1 is_stmt 1 view -0
 785               		.cfi_startproc
 786               	/* prologue: function */
 787               	/* frame size = 0 */
 788               	/* stack size = 0 */
 789               	.L__stack_usage = 0
 239:quantum/matrix.c **** }
 790               		.loc 1 239 5 view .LVU162
 239:quantum/matrix.c **** }
 791               		.loc 1 239 19 is_stmt 0 view .LVU163
 792 0000 E82F      		mov r30,r24
 793 0002 F0E0      		ldi r31,0
 794 0004 EE0F      		lsl r30
 795 0006 FF1F      		rol r31
 796               	.LVL48:
 239:quantum/matrix.c **** }
 797               		.loc 1 239 19 view .LVU164
 798 0008 E050      		subi r30,lo8(-(matrix))
 799 000a F040      		sbci r31,hi8(-(matrix))
 239:quantum/matrix.c **** }
 800               		.loc 1 239 43 view .LVU165
 801 000c 81E0      		ldi r24,lo8(1)
 802 000e 90E0      		ldi r25,0
 803 0010 6230      		cpi r22,lo8(2)
 804 0012 00F4      		brsh .L31
 805 0014 80E0      		ldi r24,0
 806               	.L31:
 239:quantum/matrix.c **** }
 807               		.loc 1 239 25 view .LVU166
 808 0016 2081      		ld r18,Z
 809 0018 3181      		ldd r19,Z+1
 810 001a 8223      		and r24,r18
 240:quantum/matrix.c **** 
 811               		.loc 1 240 1 view .LVU167
 812 001c 8170      		andi r24,lo8(1)
 813               	/* epilogue start */
 814 001e 0895      		ret
 815               		.cfi_endproc
 816               	.LFE17:
 818               		.section	.text.matrix_get_row,"ax",@progbits
 819               	.global	matrix_get_row
 821               	matrix_get_row:
 822               	.LVL49:
 823               	.LFB18:
 244:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 824               		.loc 1 244 1 is_stmt 1 view -0
 825               		.cfi_startproc
 826               	/* prologue: function */
 827               	/* frame size = 0 */
 828               	/* stack size = 0 */
 829               	.L__stack_usage = 0
 250:quantum/matrix.c **** #endif
 830               		.loc 1 250 5 view .LVU169
 250:quantum/matrix.c **** #endif
 831               		.loc 1 250 18 is_stmt 0 view .LVU170
 832 0000 E82F      		mov r30,r24
 833 0002 F0E0      		ldi r31,0
 834 0004 EE0F      		lsl r30
 835 0006 FF1F      		rol r31
 836               	.LVL50:
 250:quantum/matrix.c **** #endif
 837               		.loc 1 250 18 view .LVU171
 838 0008 E050      		subi r30,lo8(-(matrix))
 839 000a F040      		sbci r31,hi8(-(matrix))
 252:quantum/matrix.c **** 
 840               		.loc 1 252 1 view .LVU172
 841 000c 8081      		ld r24,Z
 842 000e 9181      		ldd r25,Z+1
 843               	/* epilogue start */
 844 0010 0895      		ret
 845               		.cfi_endproc
 846               	.LFE18:
 848               		.section	.text.matrix_print,"ax",@progbits
 849               	.global	matrix_print
 851               	matrix_print:
 852               	.LFB19:
 255:quantum/matrix.c ****     print_matrix_header();
 853               		.loc 1 255 1 is_stmt 1 view -0
 854               		.cfi_startproc
 855               	/* prologue: function */
 856               	/* frame size = 0 */
 857               	/* stack size = 0 */
 858               	.L__stack_usage = 0
 256:quantum/matrix.c **** 
 859               		.loc 1 256 26 view .LVU174
 258:quantum/matrix.c ****         phex(row); print(": ");
 860               		.loc 1 258 5 view .LVU175
 258:quantum/matrix.c ****         phex(row); print(": ");
 861               		.loc 1 258 10 view .LVU176
 862               	.LVL51:
 258:quantum/matrix.c ****         phex(row); print(": ");
 863               		.loc 1 258 27 view .LVU177
 864               	/* epilogue start */
 263:quantum/matrix.c **** 
 865               		.loc 1 263 1 is_stmt 0 view .LVU178
 866 0000 0895      		ret
 867               		.cfi_endproc
 868               	.LFE19:
 870               		.section	.text.matrix_key_count,"ax",@progbits
 871               	.global	matrix_key_count
 873               	matrix_key_count:
 874               	.LFB20:
 266:quantum/matrix.c ****     uint8_t count = 0;
 875               		.loc 1 266 1 is_stmt 1 view -0
 876               		.cfi_startproc
 877 0000 0F93      		push r16
 878               	.LCFI18:
 879               		.cfi_def_cfa_offset 3
 880               		.cfi_offset 16, -2
 881 0002 1F93      		push r17
 882               	.LCFI19:
 883               		.cfi_def_cfa_offset 4
 884               		.cfi_offset 17, -3
 885 0004 CF93      		push r28
 886               	.LCFI20:
 887               		.cfi_def_cfa_offset 5
 888               		.cfi_offset 28, -4
 889               	/* prologue: function */
 890               	/* frame size = 0 */
 891               	/* stack size = 3 */
 892               	.L__stack_usage = 3
 267:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 893               		.loc 1 267 5 view .LVU180
 894               	.LVL52:
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 895               		.loc 1 268 5 view .LVU181
 896               	.LBB67:
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 897               		.loc 1 268 10 view .LVU182
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 898               		.loc 1 268 25 view .LVU183
 899 0006 00E0      		ldi r16,lo8(matrix)
 900 0008 10E0      		ldi r17,hi8(matrix)
 901               	.LBE67:
 267:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 902               		.loc 1 267 13 is_stmt 0 view .LVU184
 903 000a C0E0      		ldi r28,0
 904               	.LVL53:
 905               	.L35:
 906               	.LBB68:
 269:quantum/matrix.c ****     }
 907               		.loc 1 269 9 is_stmt 1 discriminator 3 view .LVU185
 269:quantum/matrix.c ****     }
 908               		.loc 1 269 18 is_stmt 0 discriminator 3 view .LVU186
 909 000c F801      		movw r30,r16
 910 000e 8191      		ld r24,Z+
 911 0010 9191      		ld r25,Z+
 912 0012 8F01      		movw r16,r30
 913 0014 0E94 0000 		call bitpop16
 914               	.LVL54:
 269:quantum/matrix.c ****     }
 915               		.loc 1 269 15 discriminator 3 view .LVU187
 916 0018 C80F      		add r28,r24
 917               	.LVL55:
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 918               		.loc 1 268 42 is_stmt 1 discriminator 3 view .LVU188
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 919               		.loc 1 268 25 discriminator 3 view .LVU189
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 920               		.loc 1 268 5 is_stmt 0 discriminator 3 view .LVU190
 921 001a F0E0      		ldi r31,hi8(matrix+14)
 922 001c 0030      		cpi r16,lo8(matrix+14)
 923 001e 1F07      		cpc r17,r31
 924 0020 01F4      		brne .L35
 925               	.LBE68:
 271:quantum/matrix.c **** }
 926               		.loc 1 271 5 is_stmt 1 view .LVU191
 272:quantum/matrix.c **** 
 927               		.loc 1 272 1 is_stmt 0 view .LVU192
 928 0022 8C2F      		mov r24,r28
 929               	/* epilogue start */
 930 0024 CF91      		pop r28
 931               	.LVL56:
 272:quantum/matrix.c **** 
 932               		.loc 1 272 1 view .LVU193
 933 0026 1F91      		pop r17
 934 0028 0F91      		pop r16
 935 002a 0895      		ret
 936               		.cfi_endproc
 937               	.LFE20:
 939               		.section	.bss.matrix_debouncing,"aw",@nobits
 942               	matrix_debouncing:
 943 0000 0000 0000 		.zero	14
 943      0000 0000 
 943      0000 0000 
 943      0000 
 944               		.section	.bss.matrix,"aw",@nobits
 947               	matrix:
 948 0000 0000 0000 		.zero	14
 948      0000 0000 
 948      0000 0000 
 948      0000 
 949               		.section	.rodata.col_pins,"a"
 952               	col_pins:
 953 0000 F4        		.byte	-12
 954 0001 F5        		.byte	-11
 955 0002 F6        		.byte	-10
 956 0003 F7        		.byte	-9
 957 0004 31        		.byte	49
 958 0005 91        		.byte	-111
 959 0006 90        		.byte	-112
 960 0007 34        		.byte	52
 961 0008 C6        		.byte	-58
 962 0009 97        		.byte	-105
 963 000a 66        		.byte	102
 964 000b 94        		.byte	-108
 965 000c 92        		.byte	-110
 966               		.section	.rodata.row_pins,"a"
 969               	row_pins:
 970 0000 35        		.byte	53
 971 0001 36        		.byte	54
 972 0002 30        		.byte	48
 973 0003 95        		.byte	-107
 974 0004 32        		.byte	50
 975 0005 33        		.byte	51
 976 0006 93        		.byte	-109
 977               		.section	.bss.debouncing,"aw",@nobits
 980               	debouncing:
 981 0000 00        		.zero	1
 982               		.section	.bss.debouncing_time,"aw",@nobits
 985               	debouncing_time:
 986 0000 0000      		.zero	2
 987               		.text
 988               	.Letext0:
 989               		.file 3 "/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/stdint.h"
 990               		.file 4 "./tmk_core/common/debug.h"
 991               		.file 5 "./tmk_core/common/matrix.h"
 992               		.file 6 "./tmk_core/common/timer.h"
 993               		.file 7 "./tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:4      *ABS*:000000000000003f __SREG__
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:13     .text.matrix_init_user:0000000000000000 matrix_init_user
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:13     .text.matrix_init_user:0000000000000000 matrix_init_user.localalias.0
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:32     .text.matrix_init_kb:0000000000000000 matrix_init_kb
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:49     .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:66     .text.matrix_scan_user:0000000000000000 matrix_scan_user
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:81     .text.matrix_scan_kb:0000000000000000 matrix_scan_kb
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:98     .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:115    .text.matrix_rows:0000000000000000 matrix_rows
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:134    .text.matrix_cols:0000000000000000 matrix_cols
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:153    .text.matrix_init:0000000000000000 matrix_init
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:969    .rodata.row_pins:0000000000000000 row_pins
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:952    .rodata.col_pins:0000000000000000 col_pins
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:947    .bss.matrix:0000000000000000 matrix
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:942    .bss.matrix_debouncing:0000000000000000 matrix_debouncing
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:326    .text.matrix_scan:0000000000000000 matrix_scan
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:980    .bss.debouncing:0000000000000000 debouncing
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:985    .bss.debouncing_time:0000000000000000 debouncing_time
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:759    .text.matrix_is_modified:0000000000000000 matrix_is_modified
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:781    .text.matrix_is_on:0000000000000000 matrix_is_on
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:821    .text.matrix_get_row:0000000000000000 matrix_get_row
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:851    .text.matrix_print:0000000000000000 matrix_print
/var/folders/mf/5466dhw562q7lyk542tgnwkc0000gn/T//ccdk5xW2.s:873    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
timer_read
timer_elapsed
bitpop16
__do_copy_data
__do_clear_bss
